#!/bin/sh
# wg-tool — Swap/Copy/Zero/Backup + Make-Config for WireGuard client slots on AsusWRT-Merlin
#
# Usage:
#   $(basename "$0") [-d] [-r] wgcA wgcB            # SWAP A <-> B
#   $(basename "$0") [-d] [-r] -c|--copy wgcA wgcB  # COPY A -> B
#   $(basename "$0") [-d]     -z|--zero wgcA        # ZERO (erase) A
#   $(basename "$0")          -b|--backup [-m]      # BACKUP all slots, optionally write .conf too
#   $(basename "$0")          -m|--make-config /path/to/wgcX.nvram
#
# Flags:
#   -b, --backup      Backup mode (no changes to NVRAM)
#   -c, --copy        Copy mode (default is swap)
#   -d, --dry-run     Plan only; no prompt, no NVRAM changes (ignored for --backup / standalone --make-config)
#   -m, --make-config Also emit .conf (with --backup), or convert a .nvram file to .conf (standalone)
#   -r, --restart     Re-enable affected clients and restart WG (not for zero target)
#   -z, --zero        Erase mode (one slot)
#   -h, --help        Show help
#
# Behavior:
#   • Only touches wgcN_* keys (N=1..5).
#   • Each run makes /jffs/backups/wg_tool/<YYYYmmdd_HHMMSS>/ with:
#       - wgcN.nvram (key dump) and, if requested, wgcN.conf (reconstructed)
#   • swap/copy/zero: clients are forced DISABLED after apply; add -r/--restart to re-enable & restart (zero stays OFF).

set -eu

prog="$(basename "$0")"

# ---------- helpers ----------
err(){ echo "Error: $*" >&2; exit 1; }
usage(){
  cat >&2 <<USAGE
Usage:
  $prog [-d] [-r] wgcA wgcB
      Swap slot A <-> slot B  (A and B in wgc1..wgc5)

  $prog [-d] [-r] -c|--copy wgcA wgcB
      Copy slot A -> slot B   (A and B in wgc1..wgc5)

  $prog [-d] -z|--zero wgcA
      Zero (erase) slot A     (A in wgc1..wgc5)

  $prog -b|--backup [-m|--make-config]
      Backup all five slots (wgc1..wgc5) to a stamped directory.
      With -m, also generate matching wgcN.conf files.

  $prog -m|--make-config /path/to/wgcX.nvram
      Convert a saved .nvram file into a .conf with the same basename.

Flags:
  -b, --backup         Backup mode (no changes)
  -c, --copy           Copy mode (default is swap)
  -d, --dry-run        Plan only; no prompt, no changes (ignored in --backup / standalone --make-config)
  -m, --make-config    With --backup: also emit .conf per slot
                       Standalone: convert a .nvram file to .conf
  -r, --restart        Re-enable affected clients and restart WG (not for zero target)
  -z, --zero           Erase mode (one argument)
  -h, --help           Show this help
USAGE
  exit 1
}
is_slot(){ echo "$1" | grep -Eq '^wgc[1-5]$'; }
nvget(){ nvram get "$1" 2>/dev/null; }
nvset(){ nvram set "$1=$2"; }
suffixes_for(){ nvram show 2>/dev/null | grep "^$1_" | cut -d= -f1 | sed "s/^$1_//" | sort -u; }

# Build a .conf from LIVE NVRAM for a given slot into outdir
make_conf_from_slot(){
  # $1=slot $2=outdir
  local slot="$1" outdir="$2"
  local addr priv dns mtu ppub psk aips ep_host ep_port alive lport

  addr="$(nvget ${slot}_addr)"
  priv="$(nvget ${slot}_priv)"
  dns="$(nvget ${slot}_dns)"
  mtu="$(nvget ${slot}_mtu)"
  ppub="$(nvget ${slot}_ppub)"
  psk="$(nvget ${slot}_psk)"
  aips="$(nvget ${slot}_aips)"
  ep_host="$(nvget ${slot}_ep_addr)"
  ep_port="$(nvget ${slot}_ep_port)"
  alive="$(nvget ${slot}_alive)"

  # normalize comma spacing
  [ -n "$dns" ] && dns="$(printf "%s" "$dns" | sed 's/, */, /g')"
  [ -n "$aips" ] && aips="$(printf "%s" "$aips" | sed 's/, */, /g')"

  # ListenPort selection: explicit, live iface, or server port (template parity)
  lport="$(nvget ${slot}_lport)"
  [ -z "$lport" ] && lport="$(nvget ${slot}_listenport)"
  if [ -z "$lport" ] && command -v wg >/dev/null 2>&1; then
    lport="$(wg show "$slot" 2>/dev/null | awk '/listening port:/ {print $3; exit}')"
  fi
  [ -z "$lport" ] && lport="$ep_port"

  {
    echo "[Interface]"
    [ -n "$addr" ] && echo "Address = $addr"
    [ -n "$priv" ] && echo "PrivateKey = $priv"
    [ -n "$lport" ] && echo "ListenPort = $lport"
    [ -n "$dns" ] && echo "DNS = $dns"
    # include MTU only if explicitly set in nvram
    [ -n "$mtu" ] && echo "MTU = $mtu"
    echo
    echo "[Peer]"
     [ -n "$ppub" ] && echo "PublicKey = $ppub"
    [ -n "$aips" ] && echo "AllowedIPs = $aips"
    [ -n "$ep_host$ep_port" ] && echo "Endpoint = ${ep_host}:${ep_port}"
    [ -n "$alive" ] && echo "PersistentKeepalive = $alive"
    [ -n "$psk" ] && echo "PresharedKey = $psk"
  } > "${outdir}/${slot}.conf"
  chmod 600 "${outdir}/${slot}.conf" || true
}

# Build a .conf from a saved .nvram file (key=value lines) next to it
make_conf_from_nvram_file(){
  # $1=/path/to/wgcX.nvram
  local file="$1" dir base slot
  [ -f "$file" ] || err "No such file: $file"
  dir="$(dirname "$file")"
  base="$(basename "$file" .nvram)"
  slot="$(awk -F_ '/^wgc[1-5]_/{print $1; exit}' "$file")"
  [ -n "$slot" ] || err "Could not infer slot prefix from $file"

  # helper to extract "wgcX_suffix=value" (preserve trailing =)
  getkv(){
    grep -E "^${slot}_$1=" "$file" | sed -e "s/^${slot}_$1=//"
  }

  addr="$(getkv addr)"
  priv="$(getkv priv)"
  dns="$(getkv dns)"
  mtu="$(getkv mtu)"
  ppub="$(getkv ppub)"
  psk="$(getkv psk)"
  aips="$(getkv aips)"
  ep_host="$(getkv ep_addr)"
  ep_port="$(getkv ep_port)"
  alive="$(getkv alive)"
  lport="$(getkv lport)"; [ -z "$lport" ] && lport="$(getkv listenport)"
  [ -z "$lport" ] && lport="$ep_port"

  [ -n "$dns" ] && dns="$(printf "%s" "$dns" | sed 's/, */, /g')"
  [ -n "$aips" ] && aips="$(printf "%s" "$aips" | sed 's/, */, /g')"

  {
    echo "[Interface]"
    [ -n "$addr" ] && echo "Address = $addr"
    [ -n "$priv" ] && echo "PrivateKey = $priv"
    [ -n "$lport" ] && echo "ListenPort = $lport"
    [ -n "$dns" ] && echo "DNS = $dns"
    [ -n "$mtu" ] && echo "MTU = $mtu"
    echo
    echo "[Peer]"
    [ -n "$ppub" ] && echo "PublicKey = $ppub"
    [ -n "$aips" ] && echo "AllowedIPs = $aips"
    [ -n "$ep_host$ep_port" ] && echo "Endpoint = ${ep_host}:${ep_port}"
    [ -n "$alive" ] && echo "PersistentKeepalive = $alive"
    [ -n "$psk" ] && echo "PresharedKey = $psk"
  } > "${dir}/${base}.conf"
  chmod 600 "${dir}/${base}.conf" || true
  echo "Wrote ${dir}/${base}.conf"
}

snapshot_slot(){
  # $1=slot $2=outdir $3=makeconf(0/1)
  local slot="$1" outdir="$2" mk="$3" file rc
  file="${outdir}/${slot}.nvram"

  # Always create/empty the file first
  : > "$file"

  # Run grep in a conditional so set -e won't abort when there are no matches
  rc=0
  if nvram show 2>/dev/null | grep "^${slot}_" >> "$file"; then
    rc=0
  else
    # No keys for this slot; keep the file empty
    rc=0
  fi

  chmod 600 "$file" 2>/dev/null || true

  # Make a .conf only if requested
  if [ "$mk" -eq 1 ]; then
    # Never explode if something inside fails
    make_conf_from_slot "$slot" "$outdir" 2>/dev/null || true
  fi

  return 0   # <- ALWAYS succeed
}

# ---------- parse flags ----------
MODE=""         # swap|copy|zero|backup|makeconf_file
DRY=0
DO_RESTART=0
MAKECONF=0

while [ $# -gt 0 ]; do
  case "$1" in
    -b|--backup)      MODE="backup"; shift ;;
    -c|--copy)        MODE="copy"; shift ;;
    -d|--dry-run)     DRY=1; shift ;;
    -m|--make-config) MAKECONF=1; shift ;;
    -r|--restart)     DO_RESTART=1; shift ;;
    -z|--zero)        MODE="zero"; shift ;;
    -h|--help)        usage ;;
    --) shift; break ;;
    -*) err "Unknown flag: $1" ;;
    *) break ;;
  esac
done

# Standalone make-config from file?
if [ $MAKECONF -eq 1 ] && [ "${MODE:-}" = "" ] && [ $# -eq 1 ] && echo "$1" | grep -q '\.nvram$'; then
  make_conf_from_nvram_file "$1"
  exit 0
fi

# Default to swap if no explicit mode and not backup
[ -z "${MODE:-}" ] && MODE="swap"

# ---------- positional args ----------
case "$MODE" in
  backup)
    [ $# -eq 0 ] || usage
    ;;
  zero)
    [ $# -eq 1 ] || usage
    SLOT_A="$1"; is_slot "$SLOT_A" || err "Slot must be wgc1..wgc5"
    ;;
  copy|swap)
    [ $# -eq 2 ] || usage
    SLOT_A="$1"; SLOT_B="$2"
    is_slot "$SLOT_A" || err "Slot A must be wgc1..wgc5"
    is_slot "$SLOT_B" || err "Slot B must be wgc1..wgc5"
    [ "$SLOT_A" != "$SLOT_B" ] || err "Slots must be different"
    ;;
  *) err "Unknown mode: $MODE" ;;
esac

# ---------- run directory (timestamp only) ----------
TS="$(date +%Y%m%d_%H%M%S)"
RUN_DIR="/jffs/backups/wg_tool/${TS}"
mkdir -p "$RUN_DIR"; chmod 700 "$RUN_DIR"
echo "Run directory: $RUN_DIR"

# ---------- backup-only mode ----------
if [ "$MODE" = "backup" ] ; then
  echo "Mode: BACKUP (all slots)"
  for s in wgc1 wgc2 wgc3 wgc4 wgc5; do
    echo "- Snapshotting $s"
    if ! snapshot_slot "$s" "$RUN_DIR" "$MAKECONF"; then
      echo "  (warn) snapshot failed for $s; continuing"
    fi
  done
  echo "Backup complete: $RUN_DIR"
  exit 0
fi

# Pre-op snapshots of involved slots
snapshot_slot "$SLOT_A" "$RUN_DIR" "$MAKECONF"
[ "$MODE" != "zero" ] && snapshot_slot "$SLOT_B" "$RUN_DIR" "$MAKECONF"

# ---------- plan ----------
case "$MODE" in
  zero)
    A_SFX="$(suffixes_for "$SLOT_A")"
    echo "Mode: ZERO (erase) $SLOT_A"
    if [ -z "$A_SFX" ]; then
      echo "Nothing to erase: $SLOT_A has no wgc keys."
      exit 0
    fi
    echo "Keys to clear:"; for sfx in $A_SFX; do echo "  - ${SLOT_A}_${sfx}"; done
    involved_slots="$SLOT_A"
    ;;
  copy)
    A_SFX="$(suffixes_for "$SLOT_A")"
    [ -n "$A_SFX" ] || err "${SLOT_A} has no keys to copy."
    echo "Mode: COPY ${SLOT_A} → ${SLOT_B}"
    echo "Keys to copy (overwrite on ${SLOT_B}):"
    for sfx in $A_SFX; do echo "  - ${SLOT_A}_${sfx} -> ${SLOT_B}_${sfx}"; done
    involved_slots="$SLOT_A $SLOT_B"
    ;;
  swap)
    A_SFX="$(suffixes_for "$SLOT_A")"
    B_SFX="$(suffixes_for "$SLOT_B")"
    UNION_SFX="$(printf "%s\n%s\n" "$A_SFX" "$B_SFX" | sort -u)"
    echo "Mode: SWAP ${SLOT_A} ↔ ${SLOT_B}"
    echo "Keys to swap:"
    for sfx in $UNION_SFX; do echo "  - ${SLOT_A}_${sfx} ↔ ${SLOT_B}_${sfx}"; done
    involved_slots="$SLOT_A $SLOT_B"
    ;;
esac

echo
echo "Plan summary:"
echo "  • Run dir: $RUN_DIR"
case "$MODE" in
  zero) echo "  • Action: ZERO (erase) $SLOT_A" ;;
  copy) echo "  • Action: COPY $SLOT_A → $SLOT_B" ;;
  swap) echo "  • Action: SWAP $SLOT_A ↔ $SLOT_B" ;;
esac
echo "  • Post-apply default: set enable=0 on: $involved_slots"
[ ${DO_RESTART:-0} -eq 1 ] && [ "$MODE" != "zero" ] && echo "  • With --restart/-r: will re-enable $involved_slots and restart WG"
[ ${DO_RESTART:-0} -eq 1 ] && [ "$MODE" = "zero" ] && echo "  • With --restart/-r: (zero mode) erased slot remains OFF"

# Dry-run?
if [ ${DRY:-0} -eq 1 ]; then
  echo
  echo "(dry-run) No changes applied."
  exit 0
fi

# Last-chance confirmation
echo
printf "Proceed? Type Y/y to continue, any other key to abort: "
read ans || ans=""
case "$ans" in y|Y) : ;; *) echo "Aborted."; exit 1 ;; esac

# ---------- apply ----------
case "$MODE" in
  zero)
    for sfx in $A_SFX; do nvset "${SLOT_A}_${sfx}" ""; done
    ;;
  copy)
    for sfx in $A_SFX; do
      val="$(nvget "${SLOT_A}_${sfx}")"
      nvset "${SLOT_B}_${sfx}" "$val"
    done
    ;;
  swap)
    for sfx in $UNION_SFX; do
      KA="${SLOT_A}_${sfx}"; KB="${SLOT_B}_${sfx}"
      VA="$(nvget "$KA")"; VB="$(nvget "$KB")"
      nvset "$KA" "$VB"
      nvset "$KB" "$VA"
    done
    ;;
esac

# Force involved clients OFF
for slot in $involved_slots; do
  nvset "${slot}_enable" "0"
done

echo "Committing NVRAM..."
nvram commit

# Optional restart + re-enable (not for zero)
if [ ${DO_RESTART:-0} -eq 1 ] && [ "$MODE" != "zero" ]; then
  for slot in $involved_slots; do nvset "${slot}_enable" "1"; done
  nvram commit
  if command -v service >/dev/null 2>&1; then service restart_wireguard 2>/dev/null || true; fi
  echo "Applied and restarted. Re-enabled: $involved_slots"
else
  echo "Applied. Clients left DISABLED as requested."
  echo "Toggle in GUI or run again with -r/--restart to enable + restart."
fi

echo "Done. Artifacts in: $RUN_DIR"
